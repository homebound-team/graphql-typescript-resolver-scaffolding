import { PluginFunction, Types } from "@graphql-codegen/plugin-helpers";
import { pascalCase, camelCase } from "change-case";
import { promises as fs } from "fs";
import { GraphQLField, GraphQLInputObjectType, GraphQLNonNull, GraphQLObjectType } from "graphql";
import { dirname } from "path";
import { code, Code, imp, Import } from "ts-poet";
import PluginOutput = Types.PluginOutput;

// These types are generated by the graphql-typescript-simpler-resolvers plugin
const QueryResolvers = imp("QueryResolvers@src/generated/graphql-types");
const MutationResolvers = imp("MutationResolvers@src/generated/graphql-types");
const SubscriptionResolvers = imp("SubscriptionResolvers@src/generated/graphql-types");

const withFilter = imp("withFilter@graphql-subscriptions");
const SubscriptionResolverFilter = imp("SubscriptionResolverFilter@src/generated/graphql-types");
const Context = imp(`Context@src/context`);
const run = imp(`run@src/resolvers/testUtils`);

const baseDir = "src/resolvers";
const fileNamesConsideredTopLevel = [
  "schema.graphql",
  "mutations.graphql",
  "queries.graphql",
  "subscriptions.graphql",
  "root.graphql",
];

/**
 * Given a schema, generates the top-level Query/Mutation/Object resovlers by stitching
 * together the respective individual resolvers at expected locations.
 *
 * We also put scaffolding in each "expected location" place to help engineers
 * know where to put things.
 */
export const plugin: PluginFunction<Config> = async (schema, documents, config) => {
  const mutationType = schema.getMutationType();
  if (mutationType) {
    const symbols = await generateMutationScaffolding(mutationType);
    await writeBarrelFile("mutationResolvers", MutationResolvers, "mutations/index.ts", symbols);
  }

  const queryType = schema.getQueryType();
  if (queryType) {
    const symbols = await generateQueryScaffolding(queryType);
    await writeBarrelFile("queryResolvers", QueryResolvers, "queries/index.ts", symbols);
  }

  const subscriptionType = schema.getSubscriptionType();
  if (subscriptionType) {
    const symbols = await generateSubscriptionScaffolding(subscriptionType);
    await writeBarrelFile("subscriptionResolvers", SubscriptionResolvers, "subscriptions/index.ts", symbols);
  }

  // Allow config to ignore certain objects, i.e. we ignore all of our enums b/c `enumsResolvers` codegens them
  const ignoreObjectsPattern = config?.scaffolding?.ignoreObjectsPattern;
  const ignoreObjectsRegex = ignoreObjectsPattern && new RegExp(ignoreObjectsPattern);

  const objectSymbols: Record<string, Import> = {};
  await Promise.all(
    Object.values(schema.getTypeMap())
      .filter((value) => isGraphQLObjectType(value))
      .filter((value) => !value.name.startsWith("__"))
      .filter((value) => value !== queryType && value !== mutationType)
      .filter((value) => config.mappers[value.name] !== undefined)
      .filter((value) => ignoreObjectsRegex === undefined || !value.name.match(ignoreObjectsRegex))
      .map(async (o) => {
        const symbol = await generateObjectScaffolding(o as GraphQLObjectType);
        objectSymbols[(o as GraphQLObjectType).name] = symbol;
      }),
  );
  await writeObjectBarrelFile("objectResolvers", "objects/index.ts", objectSymbols);

  // We don't output any content into the generated-types.ts file.
  return {} as PluginOutput;
};

/** Given the `Query` types, generates `foo.ts` and `foo.test.ts` scaffolds for each field. */
async function generateQueryScaffolding(query: GraphQLObjectType): Promise<Import[]> {
  const cwd = await fs.realpath(".");

  // Loop over every `Query.foo` field
  const promises = Object.values(query.getFields()).map(async (field) => {
    const name = field.name;

    const argsImp = field.args.length === 0 ? "{}" : imp(`Query${pascalCase(name)}Args@src/generated/graphql-types`);

    const maybeSubDir = maybeGetSchemaFile(cwd, field);
    const modulePath = `${baseDir}/${maybeSubDir ?? "queries"}/${name}Query`;
    const resolverConst = imp(`${name}@${modulePath}`);

    const newFile = await writeIfNew(
      `${modulePath}.ts`,
      code`
        export const ${name}: Pick<${QueryResolvers}, "${name}"> = {
          async ${name}(root, args, ctx) {
            throw new Error("not implemented");
          }
        };
      `,
    );
    if (newFile) {
      await writeIfNew(
        `${modulePath}.test.ts`,
        code`
          describe("${name}", () => {
            it("handles this business case", () => {
              fail();
            });
          });

          function run${pascalCase(name)}(ctx: ${Context}, argsFn: () => ${argsImp}) {
            return ${run}(ctx, (ctx) => ${resolverConst}.${name}({}, argsFn(), ctx, undefined!));
          }
        `,
      );
    }

    return resolverConst;
  });

  return Promise.all(promises);
}

/** Given the `Mutation` type, generates `foo.ts` and `foo.test.ts` scaffolds for each field. */
async function generateMutationScaffolding(mutation: GraphQLObjectType): Promise<Import[]> {
  const cwd = await fs.realpath(".");

  const promises = Object.values(mutation.getFields()).map(async (field) => {
    const name = field.name;

    // Look for the `input: ...Input!` convention
    const inputType = getInputType(field);
    // if no inputType then make inputImp void
    const inputImp = inputType ? imp(`${inputType.name}@src/generated/graphql-types`) : "void";

    const maybeSubDir = maybeGetSchemaFile(cwd, field);
    const modulePath = `${baseDir}/${maybeSubDir ?? "mutations"}/${name}Mutation`;
    const resolverConst = imp(`${name}@${modulePath}`);

    const newFile = await writeIfNew(
      `${modulePath}.ts`,
      code`
        export const ${name}: Pick<${MutationResolvers}, "${name}"> = {
          async ${name}(root, args, ctx) {
            throw new Error("not implemented");
          }
        };
      `,
    );

    if (newFile) {
      await writeIfNew(
        `${modulePath}.test.ts`,
        code`
        describe("${name}", () => {
          it("handles this business case", () => {
            fail();
          });
        });

        function run${pascalCase(name)}(ctx: ${Context}, inputFn: () => ${inputImp}) {
          return ${run}(ctx, (ctx) => ${resolverConst}.${name}({}, { input: inputFn() }, ctx, undefined!));
        }
      `,
      );
    }

    return resolverConst;
  });

  return Promise.all(promises);
}

/** Given the `Subscription` types, generates `foo.ts` and `foo.test.ts` scaffolds for each field. */
async function generateSubscriptionScaffolding(subscription: GraphQLObjectType): Promise<Import[]> {
  const cwd = await fs.realpath(".");

  const promises = Object.values(subscription.getFields()).map(async (field) => {
    const name = field.name;
    const argsImp =
      field.args.length === 0 ? "{}" : imp(`Subscription${pascalCase(name)}Args@src/generated/graphql-types`);
    const resolverContents: Code[] = [];

    // define subscription event
    resolverContents.push(code`
        export const ${pascalCase(name)}Event = "${pascalCase(name)}Event";
      `);
    // if no args, simple implementation should do
    if (field.args.length === 0) {
      resolverContents.push(code`
          export const ${name}: Pick<${SubscriptionResolvers}, "${name}"> = {
            ${name}: {
              subscribe: () => {
                // likely can import pubsub implementation and uncomment next line
                // return pubsub.asyncIterator(${pascalCase(name)}Event);
                throw new Error("not implemented");
              }
            }
          };
        `);
    } // enable subscription filtering if args not empty
    // TODO figure out how to type the payload variable below
    else {
      resolverContents.push(code`
          export const ${name}: Pick<${SubscriptionResolvers}, "${name}"> = {
            ${name}: {
              subscribe: ${withFilter}(
                () => {
                  // likely can import pubsub implementation and uncomment next line
                  // return pubsub.asyncIterator(${pascalCase(name)}Event);
                  throw new Error("not implemented");
                },
                (payload, args: ${argsImp}) => {
                  // return true if payload / args should result in notification
                  throw new Error("not implemented");
                },
              ),
            }
          };
        `);
    }

    const maybeSubDir = maybeGetSchemaFile(cwd, field);
    const modulePath = `${baseDir}/${maybeSubDir ?? "subscriptions"}/${name}Subscription`;
    const resolverConst = imp(`${name}@${modulePath}`);
    const testContents = code`
      describe("${name}", () => {
        it("handles this business case", () => {
          fail();
        });
      });

      function run${pascalCase(name)}(ctx: ${Context}, argsFn: () => ${argsImp}) {
        return ${run}(ctx, (ctx) => ${resolverConst}.${name}.subscribe(undefined, argsFn(), ctx,undefined!));
      }
    `;

    const newFile = await writeIfNew(`${modulePath}.ts`, code`${resolverContents}`);
    if (newFile) {
      await writeIfNew(`${modulePath}.test.ts`, testContents);
    }

    return resolverConst;
  });

  return (await Promise.all(promises)).flat();
}

/** Given the (mapped) `Object` type, generates `foo.ts` and `foo.test.ts` scaffolds for each field. */
async function generateObjectScaffolding(object: GraphQLObjectType): Promise<Import> {
  const cwd = await fs.realpath(".");

  const name = camelCase(object.name);
  const resolverType = imp(`${object.name}Resolvers@src/generated/graphql-types`);
  const maybeSubDir = maybeGetSchemaFile(cwd, object);
  const modulePath = `${baseDir}/${maybeSubDir ?? "objects"}/${name}Resolvers`;
  const resolverConst = imp(`${name}Resolvers@${modulePath}`);

  const newFile = await writeIfNew(
    `${modulePath}.ts`,
    code`
        // @ts-ignore not implemented
        export const ${name}Resolvers: ${resolverType} = {
        };
      `,
  );
  if (newFile) {
    await writeIfNew(
      `${modulePath}.test.ts`,
      code`
        describe("${name}Resolvers", () => {
          it("handles this business case", () => {
            fail();
          });
        });
      `,
    );
  }

  return resolverConst;
}

/** Creates a barrel file that re-exports every symbol in `symbols`. */
async function writeBarrelFile(constName: string, constType: Import, filePath: string, symbols: Import[]) {
  const contents = code`
    // This file is auto-generated

    export const ${constName}: ${constType} = {
      ${symbols.map((symbol) => code`...${symbol},`)}
    }
  `;
  await fs.writeFile(`${baseDir}/${filePath}`, contents.toString({ path: filePath }));
}

/** Creates a barrel file that re-exports every symbol in `symbols`. */
async function writeObjectBarrelFile(constName: string, filePath: string, symbols: Record<string, Import>) {
  const contents = code`
    // This file is auto-generated

    export const ${constName} = {
      ${Object.entries(sortObject(symbols)).map(([name, symbol]) => code`${name}: ${symbol},`)}
    }
  `;
  await fs.writeFile(`${baseDir}/${filePath}`, contents.toString({ path: filePath }));
}

/** Assumes the mutation has a single `Input`-style parameter, which should be non-null. */
function getInputType(field: GraphQLField<any, any>): GraphQLInputObjectType | undefined {
  if (field.args.length > 0) {
    if (field.args[0].type instanceof GraphQLNonNull) {
      return field.args[0].type.ofType as any as GraphQLInputObjectType;
    } else if (field.args[0].type instanceof GraphQLInputObjectType) {
      return field.args[0].type;
    }
  }
  return undefined;
}

type HasAst = GraphQLObjectType | GraphQLField<any, any>;

/**
 * Finds the relative path within the `$projectDir/schema/` directory.
 *
 * I.e. given `node` is a `type Author`, returns the `author.graphql` file.
 */
function relativeSourcePath(cwd: string, node: HasAst): string | undefined {
  let source: string | undefined;
  if (node instanceof GraphQLObjectType && Object.values(node.getFields()).length > 0) {
    // There is a bug in graphql-codegen/graphql-toolkit where the top-level objects don't
    // have source locations, but if we call .getFields() and look at the first field, it works.
    //
    // That said, the "first field" might be in a file that is doing `extends type ...`, so
    // our heuristic is to look at all of the fields and pick the most-used source name.

    // group by and count. Yuck.
    const fieldSources = Object.values(node.getFields())
      .map((f) => f.astNode?.loc?.source.name)
      .reduce(
        (acc, name) => {
          if (name) {
            if (acc[name]) {
              acc[name]++;
            } else {
              acc[name] = 1;
            }
          }
          return acc;
        },
        {} as Record<string, number>,
      );

    // Find the max. Yuck.
    const fieldSource = Object.entries(fieldSources).reduce((max, next) => {
      if (next[1] > max[1]) {
        return next;
      } else {
        return max;
      }
    });

    source = fieldSource[0];
  } else if (!(node instanceof GraphQLObjectType)) {
    source = node.astNode?.loc?.source.name;
  }
  if (source) {
    // Assume files are in `./schema/*.graphql` files.
    return source.replace(cwd, "")?.replace("/schema/", "");
  }
  return undefined;
}

/** Given `field` is in `author.graphql`, returns `author` as the base file prefix. */
function maybeGetSchemaFile(cwd: string, field: HasAst): string | undefined {
  const path = relativeSourcePath(cwd, field);
  const shouldGoInTopLevel = path && fileNamesConsideredTopLevel.includes(path);
  return !path || shouldGoInTopLevel ? undefined : path.replace(".graphql", "");
}

async function writeIfNew(path: string, code: Code): Promise<boolean> {
  await fs.mkdir(dirname(path), { recursive: true });
  const exists = await trueIfResolved(fs.access(path));
  if (!exists) {
    await fs.writeFile(path, code.toString({ path }));
    return true;
  }
  return false;
}

/** The config values we read from the graphql-codegen.yml file. */
export type Config = {
  contextType: string;
  mappers: Record<string, string>;
  scaffolding?: {
    ignoreObjectsPattern?: string;
  };
};

/** Returns true if `p` is resolved, otherwise false if it is rejected. */
export async function trueIfResolved(p: Promise<unknown>): Promise<boolean> {
  return await p.then(
    () => true,
    () => false,
  );
}

function sortObject<T extends object>(obj: T): T {
  return Object.keys(obj)
    .sort()
    .reduce(
      (acc, key) => {
        acc[key as keyof T] = obj[key as keyof T];
        return acc;
      },
      {} as any as T,
    ) as T;
}

function isGraphQLObjectType(o: any): o is GraphQLObjectType {
  return o instanceof GraphQLObjectType;
}
